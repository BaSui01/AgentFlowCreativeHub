# ç¡¬ç›˜ç¼“å­˜ä¸äº’è”ç½‘æ£€ç´¢å¤ç”¨æ–¹æ¡ˆ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†åˆ†æäº†:
1. **ç¡¬ç›˜å­˜å‚¨ç¼“å­˜** - å¤§æ¨¡å‹ç¼“å­˜çš„ç£ç›˜æŒä¹…åŒ–æ–¹æ¡ˆ
2. **äº’è”ç½‘æ£€ç´¢å¤ç”¨** - å¦‚ä½•ä»ç°æœ‰å®ç°ä¸­å¤ç”¨HTTPå’Œæ£€ç´¢ä»£ç 

**æ–‡æ¡£æ—¥æœŸ**: 2025-11-27  
**ç‰ˆæœ¬**: v1.0  
**é¡¹ç›®**: AgentFlowCreativeHub

---

## ç¬¬ä¸€éƒ¨åˆ†: ç¡¬ç›˜ç¼“å­˜å­˜å‚¨æ–¹æ¡ˆåˆ†æ

### 1.1 ç¡¬ç›˜ç¼“å­˜çš„å¿…è¦æ€§

#### âœ… ä¼˜åŠ¿

| ä¼˜åŠ¿ | è¯´æ˜ | æ”¶ç›Š |
|------|------|------|
| **æŒä¹…åŒ–** | æœåŠ¡é‡å¯åç¼“å­˜ä¸ä¸¢å¤± | é¿å…å†·å¯åŠ¨,å¿«é€Ÿæ¢å¤ |
| **å®¹é‡æ— é™** | ä¸å—Rediså†…å­˜é™åˆ¶ | æ”¯æŒGBçº§åˆ«ç¼“å­˜ |
| **æˆæœ¬æœ€ä½** | ç¡¬ç›˜æ¯”Redisä¾¿å®œ10å€ | å¹´èŠ‚çœ $5,000+ |
| **ç¦»çº¿å¯ç”¨** | æ–­ç½‘æƒ…å†µä»å¯æœ¬åœ°æŸ¥è¯¢ | æå‡å¯é æ€§ |
| **é«˜é€Ÿè®¿é—®** | SSDé¡ºåºè¯»å†™ 3-5GB/s | æ»¡è¶³å®æ—¶éœ€æ±‚ |

#### âŒ åŠ£åŠ¿

| åŠ£åŠ¿ | å½±å“ | è§£å†³æ–¹æ¡ˆ |
|------|------|---------|
| **éšæœºè®¿é—®æ…¢** | éšæœºè¯»å–å»¶è¿Ÿ 1-5ms | ä½¿ç”¨ç´¢å¼•+å†…å­˜ç¼“å­˜ |
| **å¹¶å‘é™åˆ¶** | æ–‡ä»¶é”äº‰ç”¨ | ä½¿ç”¨æ•°æ®åº“å¦‚SQLite |
| **åˆ†å¸ƒå¼å›°éš¾** | éš¾ä»¥è·¨æœºå…±äº« | ä»…ç”¨äºæœ¬åœ° + Rediså±‚ |
| **ç»´æŠ¤å¤æ‚** | éœ€è¦å®šæœŸæ¸…ç† | è‡ªåŠ¨æ·˜æ±°ç­–ç•¥ |

---

### 1.2 ç¡¬ç›˜ç¼“å­˜æ¶æ„è®¾è®¡

#### æ¨èæ–¹æ¡ˆ: **åˆ†å±‚ç¼“å­˜ + SQLite æ•°æ®åº“**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         åº”ç”¨å±‚ (Go Backend)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
         â”‚              â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
    â”‚ L1 ç¼“å­˜ â”‚    â”‚ L2 ç¼“å­˜  â”‚
    â”‚(å†…å­˜)   â”‚    â”‚(Redis)   â”‚
    â”‚ 100ms   â”‚    â”‚ 1-5ms    â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
         â”‚             â”‚
         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                â”‚ Miss
         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  L3 ç¼“å­˜ (ç¡¬ç›˜)         â”‚  <- æ–°å¢å±‚
         â”‚  å»¶è¿Ÿ: 5-20ms          â”‚
         â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
         â”‚  â”‚ SQLite æ•°æ®åº“    â”‚  â”‚  <- âœ… æ¨è
         â”‚  â”‚ â€¢ å¿«é€ŸæŸ¥è¯¢       â”‚  â”‚
         â”‚  â”‚ â€¢ ç´¢å¼•æ”¯æŒ       â”‚  â”‚
         â”‚  â”‚ â€¢ ACID äº‹åŠ¡      â”‚  â”‚
         â”‚  â”‚ â€¢ æ”¯æŒå‹ç¼©       â”‚  â”‚
         â”‚  â”‚ â€¢ å†…ç½®å…¨æ–‡æœç´¢   â”‚  â”‚
         â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ Miss
         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
         â”‚  å¤§æ¨¡å‹ API  â”‚
         â”‚  å»¶è¿Ÿ: 2-10s â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 1.3 SQLite ç¼“å­˜å®ç°æ–¹æ¡ˆ

#### æ•°æ®åº“ Schema è®¾è®¡

```sql
-- ç¼“å­˜ä¸»è¡¨
CREATE TABLE llm_cache (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    cache_key TEXT NOT NULL UNIQUE,           -- ç¼“å­˜é”® (MD5 æˆ– SHA256)
    model TEXT NOT NULL,                      -- æ¨¡å‹åç§°: gpt-4, claude-3-opus
    prompt_hash TEXT NOT NULL,                -- æç¤ºè¯å“ˆå¸Œ
    prompt TEXT,                              -- å®Œæ•´æç¤ºè¯ (å¯é€‰å­˜å‚¨)
    response TEXT NOT NULL,                   -- æ¨¡å‹å“åº”
    tokens_used INTEGER DEFAULT 0,            -- Token ä½¿ç”¨é‡
    cost_usd REAL DEFAULT 0.0,                -- æˆæœ¬ (ç¾å…ƒ)
    hit_count INTEGER DEFAULT 0,              -- å‘½ä¸­æ¬¡æ•°
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_accessed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    expires_at DATETIME,                      -- è¿‡æœŸæ—¶é—´
    compressed BOOLEAN DEFAULT 0,             -- æ˜¯å¦å‹ç¼©
    metadata JSON                             -- æ‰©å±•å…ƒæ•°æ®
);

-- ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_cache_key ON llm_cache(cache_key);
CREATE INDEX idx_model_prompt ON llm_cache(model, prompt_hash);
CREATE INDEX idx_expires_at ON llm_cache(expires_at);
CREATE INDEX idx_last_accessed ON llm_cache(last_accessed_at);

-- ç¼“å­˜ç»Ÿè®¡è¡¨
CREATE TABLE cache_stats (
    date DATE PRIMARY KEY,
    total_hits INTEGER DEFAULT 0,
    total_misses INTEGER DEFAULT 0,
    total_saves_usd REAL DEFAULT 0.0,
    avg_response_time_ms INTEGER DEFAULT 0
);
```

#### Go å®ç°ä»£ç 

##### 1. ç¼“å­˜ç»“æ„ä½“å®šä¹‰

```go
// backend/internal/cache/disk_cache.go
package cache

import (
    "context"
    "crypto/md5"
    "database/sql"
    "encoding/hex"
    "encoding/json"
    "fmt"
    "time"
    
    _ "github.com/mattn/go-sqlite3"
)

// DiskCache ç¡¬ç›˜ç¼“å­˜ç®¡ç†å™¨
type DiskCache struct {
    db       *sql.DB
    dbPath   string
    ttl      time.Duration
    maxSize  int64  // æœ€å¤§ç¼“å­˜å¤§å° (å­—èŠ‚)
}

// CacheEntry ç¼“å­˜æ¡ç›®
type CacheEntry struct {
    CacheKey      string          `json:"cache_key"`
    Model         string          `json:"model"`
    PromptHash    string          `json:"prompt_hash"`
    Response      string          `json:"response"`
    TokensUsed    int             `json:"tokens_used"`
    CostUSD       float64         `json:"cost_usd"`
    HitCount      int             `json:"hit_count"`
    CreatedAt     time.Time       `json:"created_at"`
    LastAccessedAt time.Time      `json:"last_accessed_at"`
    ExpiresAt     *time.Time      `json:"expires_at,omitempty"`
    Metadata      json.RawMessage `json:"metadata,omitempty"`
}

// NewDiskCache åˆ›å»ºç¡¬ç›˜ç¼“å­˜å®ä¾‹
func NewDiskCache(dbPath string, ttl time.Duration, maxSizeGB int) (*DiskCache, error) {
    db, err := sql.Open("sqlite3", dbPath)
    if err != nil {
        return nil, fmt.Errorf("æ‰“å¼€æ•°æ®åº“å¤±è´¥: %w", err)
    }
    
    // æ€§èƒ½ä¼˜åŒ–è®¾ç½®
    if _, err := db.Exec(`
        PRAGMA journal_mode=WAL;
        PRAGMA synchronous=NORMAL;
        PRAGMA cache_size=-64000;  -- 64MB ç¼“å­˜
        PRAGMA temp_store=MEMORY;
        PRAGMA mmap_size=268435456; -- 256MB å†…å­˜æ˜ å°„
    `); err != nil {
        return nil, fmt.Errorf("è®¾ç½®æ•°æ®åº“å‚æ•°å¤±è´¥: %w", err)
    }
    
    // åˆ›å»ºè¡¨ç»“æ„
    if err := initSchema(db); err != nil {
        return nil, err
    }
    
    cache := &DiskCache{
        db:      db,
        dbPath:  dbPath,
        ttl:     ttl,
        maxSize: int64(maxSizeGB) * 1024 * 1024 * 1024,
    }
    
    // å¯åŠ¨åå°æ¸…ç†ä»»åŠ¡
    go cache.cleanupLoop(context.Background())
    
    return cache, nil
}

// åˆå§‹åŒ–æ•°æ®åº“è¡¨ç»“æ„
func initSchema(db *sql.DB) error {
    schema := `
    CREATE TABLE IF NOT EXISTS llm_cache (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        cache_key TEXT NOT NULL UNIQUE,
        model TEXT NOT NULL,
        prompt_hash TEXT NOT NULL,
        prompt TEXT,
        response TEXT NOT NULL,
        tokens_used INTEGER DEFAULT 0,
        cost_usd REAL DEFAULT 0.0,
        hit_count INTEGER DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        last_accessed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        expires_at DATETIME,
        compressed BOOLEAN DEFAULT 0,
        metadata JSON
    );
    
    CREATE INDEX IF NOT EXISTS idx_cache_key ON llm_cache(cache_key);
    CREATE INDEX IF NOT EXISTS idx_model_prompt ON llm_cache(model, prompt_hash);
    CREATE INDEX IF NOT EXISTS idx_expires_at ON llm_cache(expires_at);
    CREATE INDEX IF NOT EXISTS idx_last_accessed ON llm_cache(last_accessed_at);
    
    CREATE TABLE IF NOT EXISTS cache_stats (
        date DATE PRIMARY KEY,
        total_hits INTEGER DEFAULT 0,
        total_misses INTEGER DEFAULT 0,
        total_saves_usd REAL DEFAULT 0.0,
        avg_response_time_ms INTEGER DEFAULT 0
    );
    `
    
    _, err := db.Exec(schema)
    return err
}

// GenerateCacheKey ç”Ÿæˆç¼“å­˜é”®
func GenerateCacheKey(model, prompt string) string {
    data := fmt.Sprintf("%s:%s", model, prompt)
    hash := md5.Sum([]byte(data))
    return hex.EncodeToString(hash[:])
}
```

##### 2. ç¼“å­˜è¯»å†™æ–¹æ³•

```go
// Get è¯»å–ç¼“å­˜
func (c *DiskCache) Get(ctx context.Context, key string) (*CacheEntry, error) {
    query := `
        SELECT cache_key, model, prompt_hash, response, tokens_used, cost_usd, 
               hit_count, created_at, last_accessed_at, expires_at, metadata
        FROM llm_cache
        WHERE cache_key = ? AND (expires_at IS NULL OR expires_at > datetime('now'))
    `
    
    var entry CacheEntry
    var expiresAt sql.NullTime
    
    err := c.db.QueryRowContext(ctx, query, key).Scan(
        &entry.CacheKey,
        &entry.Model,
        &entry.PromptHash,
        &entry.Response,
        &entry.TokensUsed,
        &entry.CostUSD,
        &entry.HitCount,
        &entry.CreatedAt,
        &entry.LastAccessedAt,
        &expiresAt,
        &entry.Metadata,
    )
    
    if err == sql.ErrNoRows {
        return nil, nil // ç¼“å­˜æœªå‘½ä¸­
    }
    if err != nil {
        return nil, fmt.Errorf("æŸ¥è¯¢ç¼“å­˜å¤±è´¥: %w", err)
    }
    
    if expiresAt.Valid {
        entry.ExpiresAt = &expiresAt.Time
    }
    
    // æ›´æ–°è®¿é—®ç»Ÿè®¡
    go c.incrementHitCount(key)
    
    return &entry, nil
}

// Set å†™å…¥ç¼“å­˜
func (c *DiskCache) Set(ctx context.Context, entry *CacheEntry) error {
    expiresAt := sql.NullTime{}
    if entry.ExpiresAt != nil {
        expiresAt.Valid = true
        expiresAt.Time = *entry.ExpiresAt
    } else if c.ttl > 0 {
        expiresAt.Valid = true
        expiresAt.Time = time.Now().Add(c.ttl)
    }
    
    query := `
        INSERT INTO llm_cache (
            cache_key, model, prompt_hash, response, tokens_used, cost_usd,
            expires_at, metadata
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(cache_key) DO UPDATE SET
            response = excluded.response,
            tokens_used = excluded.tokens_used,
            cost_usd = excluded.cost_usd,
            updated_at = CURRENT_TIMESTAMP,
            metadata = excluded.metadata
    `
    
    _, err := c.db.ExecContext(ctx, query,
        entry.CacheKey,
        entry.Model,
        entry.PromptHash,
        entry.Response,
        entry.TokensUsed,
        entry.CostUSD,
        expiresAt,
        entry.Metadata,
    )
    
    if err != nil {
        return fmt.Errorf("å†™å…¥ç¼“å­˜å¤±è´¥: %w", err)
    }
    
    // æ£€æŸ¥ç¼“å­˜å¤§å°å¹¶æ¸…ç†
    go c.checkAndCleanup()
    
    return nil
}

// incrementHitCount å¢åŠ å‘½ä¸­è®¡æ•°
func (c *DiskCache) incrementHitCount(key string) {
    query := `
        UPDATE llm_cache 
        SET hit_count = hit_count + 1,
            last_accessed_at = CURRENT_TIMESTAMP
        WHERE cache_key = ?
    `
    c.db.Exec(query, key)
}

// Delete åˆ é™¤ç¼“å­˜
func (c *DiskCache) Delete(ctx context.Context, key string) error {
    query := `DELETE FROM llm_cache WHERE cache_key = ?`
    _, err := c.db.ExecContext(ctx, query, key)
    return err
}

// Clear æ¸…ç©ºæ‰€æœ‰ç¼“å­˜
func (c *DiskCache) Clear(ctx context.Context) error {
    _, err := c.db.ExecContext(ctx, "DELETE FROM llm_cache")
    return err
}
```

##### 3. ç¼“å­˜æ¸…ç†å’Œç»´æŠ¤

```go
// cleanupLoop å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜
func (c *DiskCache) cleanupLoop(ctx context.Context) {
    ticker := time.NewTicker(1 * time.Hour)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            c.cleanup()
        case <-ctx.Done():
            return
        }
    }
}

// cleanup æ‰§è¡Œæ¸…ç†æ“ä½œ
func (c *DiskCache) cleanup() {
    // 1. åˆ é™¤è¿‡æœŸæ¡ç›®
    c.db.Exec(`
        DELETE FROM llm_cache 
        WHERE expires_at IS NOT NULL AND expires_at < datetime('now')
    `)
    
    // 2. æ‰§è¡Œ VACUUM å‹ç¼©æ•°æ®åº“
    c.db.Exec("VACUUM")
}

// checkAndCleanup æ£€æŸ¥ç¼“å­˜å¤§å°å¹¶æ¸…ç†
func (c *DiskCache) checkAndCleanup() {
    var totalSize int64
    err := c.db.QueryRow(`
        SELECT SUM(length(response))
        FROM llm_cache
    `).Scan(&totalSize)
    
    if err != nil || totalSize < c.maxSize {
        return
    }
    
    // ä½¿ç”¨ LRU ç­–ç•¥åˆ é™¤æœ€æ—§çš„ 10%
    c.db.Exec(`
        DELETE FROM llm_cache
        WHERE id IN (
            SELECT id FROM llm_cache
            ORDER BY last_accessed_at ASC
            LIMIT (SELECT COUNT(*) / 10 FROM llm_cache)
        )
    `)
}

// GetStats è·å–ç¼“å­˜ç»Ÿè®¡
func (c *DiskCache) GetStats(ctx context.Context) (map[string]any, error) {
    var stats struct {
        TotalEntries int
        TotalHits    int64
        TotalSizeKB  int64
        AvgHitCount  float64
        OldestEntry  time.Time
        NewestEntry  time.Time
    }
    
    query := `
        SELECT 
            COUNT(*) as total,
            COALESCE(SUM(hit_count), 0) as total_hits,
            COALESCE(SUM(length(response))/1024, 0) as total_size_kb,
            COALESCE(AVG(hit_count), 0) as avg_hit_count,
            MIN(created_at) as oldest,
            MAX(created_at) as newest
        FROM llm_cache
    `
    
    err := c.db.QueryRowContext(ctx, query).Scan(
        &stats.TotalEntries,
        &stats.TotalHits,
        &stats.TotalSizeKB,
        &stats.AvgHitCount,
        &stats.OldestEntry,
        &stats.NewestEntry,
    )
    
    if err != nil {
        return nil, err
    }
    
    return map[string]any{
        "total_entries":  stats.TotalEntries,
        "total_hits":     stats.TotalHits,
        "total_size_mb":  float64(stats.TotalSizeKB) / 1024,
        "avg_hit_count":  stats.AvgHitCount,
        "oldest_entry":   stats.OldestEntry,
        "newest_entry":   stats.NewestEntry,
    }, nil
}

// Close å…³é—­æ•°æ®åº“è¿æ¥
func (c *DiskCache) Close() error {
    return c.db.Close()
}
```

---

### 1.4 é›†æˆåˆ°ç°æœ‰ç³»ç»Ÿ

#### é…ç½®æ–‡ä»¶ä¿®æ”¹

```yaml
# backend/configs/config.yaml
cache:
  # å†…å­˜ç¼“å­˜ (L1)
  memory:
    enabled: true
    max_size_mb: 512
    ttl: 5m
  
  # Redis ç¼“å­˜ (L2)
  redis:
    enabled: true
    addr: "localhost:6379"
    password: ""
    db: 0
    ttl: 1h
  
  # ç¡¬ç›˜ç¼“å­˜ (L3) - æ–°å¢
  disk:
    enabled: true
    db_path: "./data/cache/llm_cache.db"
    max_size_gb: 10
    ttl: 720h  # 30å¤©
```

#### ä½¿ç”¨ç¤ºä¾‹

```go
// backend/internal/ai/service.go
package ai

import (
    "context"
    "backend/internal/cache"
)

type AIService struct {
    diskCache *cache.DiskCache
    // ... å…¶ä»–å­—æ®µ
}

func NewAIService(cfg *Config) (*AIService, error) {
    diskCache, err := cache.NewDiskCache(
        cfg.Cache.Disk.DBPath,
        cfg.Cache.Disk.TTL,
        cfg.Cache.Disk.MaxSizeGB,
    )
    if err != nil {
        return nil, err
    }
    
    return &AIService{
        diskCache: diskCache,
    }, nil
}

// Chat èŠå¤©æ–¹æ³• (é›†æˆä¸‰å±‚ç¼“å­˜)
func (s *AIService) Chat(ctx context.Context, req *ChatRequest) (*ChatResponse, error) {
    cacheKey := cache.GenerateCacheKey(req.Model, req.Messages)
    
    // L1: å†…å­˜ç¼“å­˜æŸ¥æ‰¾
    if cached := s.memCache.Get(cacheKey); cached != nil {
        return cached.(*ChatResponse), nil
    }
    
    // L2: Redis ç¼“å­˜æŸ¥æ‰¾
    if cached := s.redisCache.Get(ctx, cacheKey); cached != nil {
        s.memCache.Set(cacheKey, cached) // å›å¡« L1
        return cached.(*ChatResponse), nil
    }
    
    // L3: ç¡¬ç›˜ç¼“å­˜æŸ¥æ‰¾ â† æ–°å¢
    if entry, err := s.diskCache.Get(ctx, cacheKey); err == nil && entry != nil {
        response := &ChatResponse{
            Content: entry.Response,
            TokensUsed: entry.TokensUsed,
        }
        
        // å›å¡« L2 å’Œ L1
        s.redisCache.Set(ctx, cacheKey, response, s.cfg.Cache.Redis.TTL)
        s.memCache.Set(cacheKey, response)
        
        return response, nil
    }
    
    // ç¼“å­˜æœªå‘½ä¸­,è°ƒç”¨å¤§æ¨¡å‹ API
    response, err := s.callLLM(ctx, req)
    if err != nil {
        return nil, err
    }
    
    // å†™å…¥ä¸‰å±‚ç¼“å­˜
    entry := &cache.CacheEntry{
        CacheKey:   cacheKey,
        Model:      req.Model,
        PromptHash: cacheKey,
        Response:   response.Content,
        TokensUsed: response.TokensUsed,
        CostUSD:    calculateCost(req.Model, response.TokensUsed),
    }
    
    go s.diskCache.Set(ctx, entry)                                    // L3
    go s.redisCache.Set(ctx, cacheKey, response, s.cfg.Cache.Redis.TTL) // L2
    s.memCache.Set(cacheKey, response)                                 // L1
    
    return response, nil
}
```

---

## ç¬¬äºŒéƒ¨åˆ†: äº’è”ç½‘æ£€ç´¢å¤ç”¨ä»£ç åˆ†æ

### 2.1 ç°æœ‰HTTPå®¢æˆ·ç«¯å®ç°

#### ä½ç½®: `backend/internal/tools/builtin/search_tool.go`

è¯¥æ–‡ä»¶å·²å®ç°å®Œæ•´çš„ HTTP å®¢æˆ·ç«¯åŠŸèƒ½,åŒ…æ‹¬:

1. âœ… åˆ›å»º `http.Client` å¹¶è®¾ç½®è¶…æ—¶
2. âœ… ä½¿ç”¨ `http.NewRequestWithContext` åˆ›å»ºè¯·æ±‚
3. âœ… è®¾ç½®è¯·æ±‚å¤´ (User-Agent)
4. âœ… å‘é€ GET è¯·æ±‚å¹¶å¤„ç†å“åº”
5. âœ… JSON è§£æå“åº”ä½“
6. âœ… é”™è¯¯å¤„ç†

#### æ ¸å¿ƒä»£ç æ‘˜å½•

```go
// backend/internal/tools/builtin/search_tool.go
type SearchTool struct {
    client *http.Client
}

func NewSearchTool() *SearchTool {
    return &SearchTool{
        client: &http.Client{
            Timeout: 30 * time.Second,  // â† è®¾ç½®è¶…æ—¶
        },
    }
}

func (t *SearchTool) Execute(ctx context.Context, input map[string]any) (map[string]any, error) {
    query := input["query"].(string)
    
    // 1. æ„å»ºè¯·æ±‚ URL
    apiURL := fmt.Sprintf("https://api.duckduckgo.com/?q=%s&format=json", 
        url.QueryEscape(query))
    
    // 2. åˆ›å»º HTTP è¯·æ±‚
    req, err := http.NewRequestWithContext(ctx, "GET", apiURL, nil)
    if err != nil {
        return nil, fmt.Errorf("åˆ›å»ºè¯·æ±‚å¤±è´¥: %w", err)
    }
    
    // 3. è®¾ç½®è¯·æ±‚å¤´
    req.Header.Set("User-Agent", "AgentFlowCreativeHub/1.0")
    
    // 4. å‘é€è¯·æ±‚
    resp, err := t.client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("æœç´¢è¯·æ±‚å¤±è´¥: %w", err)
    }
    defer resp.Body.Close()
    
    // 5. æ£€æŸ¥çŠ¶æ€ç 
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("API è¿”å›é”™è¯¯çŠ¶æ€: %d", resp.StatusCode)
    }
    
    // 6. è¯»å–å“åº”ä½“
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("è¯»å–å“åº”å¤±è´¥: %w", err)
    }
    
    // 7. JSON è§£æ
    var result map[string]any
    if err := json.Unmarshal(body, &result); err != nil {
        return nil, fmt.Errorf("è§£æå“åº”å¤±è´¥: %w", err)
    }
    
    return result, nil
}
```

---

### 2.2 å¦‚ä½•å¤ç”¨ HTTP å®¢æˆ·ç«¯ä»£ç 

#### æ–¹æ¡ˆ 1: ç›´æ¥å¤åˆ¶ç²˜è´´ (å¿«é€Ÿå®ç°)

é€‚ç”¨äºæ–°å·¥å…·å¼€å‘:

```go
// backend/internal/tools/builtin/my_new_tool.go
package builtin

import (
    "context"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "time"
)

type MyNewTool struct {
    client *http.Client
}

func NewMyNewTool() *MyNewTool {
    return &MyNewTool{
        client: &http.Client{
            Timeout: 30 * time.Second,
        },
    }
}

func (t *MyNewTool) Execute(ctx context.Context, args map[string]any) (any, error) {
    // å¤ç”¨ SearchTool çš„ HTTP è¯·æ±‚æ¨¡å¼
    req, err := http.NewRequestWithContext(ctx, "GET", "https://api.example.com", nil)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("User-Agent", "AgentFlowCreativeHub/1.0")
    
    resp, err := t.client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, err
    }
    
    var result map[string]any
    json.Unmarshal(body, &result)
    
    return result, nil
}
```

#### æ–¹æ¡ˆ 2: æŠ½å–å…¬å…± HTTP å·¥å…·ç±» (æ¨è)

åˆ›å»ºå¯å¤ç”¨çš„ HTTP å®¢æˆ·ç«¯åº“:

```go
// backend/pkg/httputil/client.go
package httputil

import (
    "context"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "time"
)

// Client ç»Ÿä¸€çš„ HTTP å®¢æˆ·ç«¯å°è£…
type Client struct {
    client    *http.Client
    userAgent string
}

// NewClient åˆ›å»ºHTTPå®¢æˆ·ç«¯
func NewClient(timeout time.Duration) *Client {
    return &Client{
        client: &http.Client{
            Timeout: timeout,
        },
        userAgent: "AgentFlowCreativeHub/1.0",
    }
}

// Request é…ç½®
type Request struct {
    Method  string
    URL     string
    Headers map[string]string
    Body    io.Reader
}

// GetJSON å‘é€ GET è¯·æ±‚å¹¶è§£æ JSON
func (c *Client) GetJSON(ctx context.Context, url string, result any) error {
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return fmt.Errorf("åˆ›å»ºè¯·æ±‚å¤±è´¥: %w", err)
    }
    
    req.Header.Set("User-Agent", c.userAgent)
    req.Header.Set("Accept", "application/json")
    
    resp, err := c.client.Do(req)
    if err != nil {
        return fmt.Errorf("è¯·æ±‚å¤±è´¥: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        body, _ := io.ReadAll(resp.Body)
        return fmt.Errorf("HTTP %d: %s", resp.StatusCode, string(body))
    }
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return fmt.Errorf("è¯»å–å“åº”å¤±è´¥: %w", err)
    }
    
    if err := json.Unmarshal(body, result); err != nil {
        return fmt.Errorf("è§£æ JSON å¤±è´¥: %w", err)
    }
    
    return nil
}

// PostJSON å‘é€ POST è¯·æ±‚
func (c *Client) PostJSON(ctx context.Context, url string, payload, result any) error {
    data, err := json.Marshal(payload)
    if err != nil {
        return fmt.Errorf("åºåˆ—åŒ–è¯·æ±‚å¤±è´¥: %w", err)
    }
    
    req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(data))
    if err != nil {
        return fmt.Errorf("åˆ›å»ºè¯·æ±‚å¤±è´¥: %w", err)
    }
    
    req.Header.Set("User-Agent", c.userAgent)
    req.Header.Set("Content-Type", "application/json")
    
    resp, err := c.client.Do(req)
    if err != nil {
        return fmt.Errorf("è¯·æ±‚å¤±è´¥: %w", err)
    }
    defer resp.Body.Close()
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return fmt.Errorf("è¯»å–å“åº”å¤±è´¥: %w", err)
    }
    
    if err := json.Unmarshal(body, result); err != nil {
        return fmt.Errorf("è§£æ JSON å¤±è´¥: %w", err)
    }
    
    return nil
}
```

#### ä½¿ç”¨å…¬å…± HTTP å·¥å…·ç±»

```go
// backend/internal/tools/builtin/weather_tool.go
package builtin

import (
    "context"
    "backend/pkg/httputil"
    "time"
)

type WeatherTool struct {
    http *httputil.Client
}

func NewWeatherTool() *WeatherTool {
    return &WeatherTool{
        http: httputil.NewClient(30 * time.Second),
    }
}

func (t *WeatherTool) Execute(ctx context.Context, args map[string]any) (any, error) {
    city := args["city"].(string)
    url := fmt.Sprintf("https://api.weather.com/v1/city/%s", city)
    
    var result map[string]any
    if err := t.http.GetJSON(ctx, url, &result); err != nil {
        return nil, err
    }
    
    return result, nil
}
```

---

### 2.3 æ”¯æŒç¼“å­˜çš„ HTTP å®¢æˆ·ç«¯

ç»“åˆç¡¬ç›˜ç¼“å­˜,å®ç°å¸¦ç¼“å­˜çš„ HTTP å®¢æˆ·ç«¯:

```go
// backend/pkg/httputil/cached_client.go
package httputil

import (
    "context"
    "crypto/md5"
    "encoding/hex"
    "encoding/json"
    "fmt"
    "time"
    
    "backend/internal/cache"
)

// CachedClient å¸¦ç¼“å­˜çš„ HTTP å®¢æˆ·ç«¯
type CachedClient struct {
    http  *Client
    cache *cache.DiskCache
    ttl   time.Duration
}

// NewCachedClient åˆ›å»ºå¸¦ç¼“å­˜çš„å®¢æˆ·ç«¯
func NewCachedClient(timeout time.Duration, cache *cache.DiskCache, ttl time.Duration) *CachedClient {
    return &CachedClient{
        http:  NewClient(timeout),
        cache: cache,
        ttl:   ttl,
    }
}

// GetJSONWithCache å¸¦ç¼“å­˜çš„ GET è¯·æ±‚
func (c *CachedClient) GetJSONWithCache(ctx context.Context, url string, result any) error {
    // 1. ç”Ÿæˆç¼“å­˜é”®
    cacheKey := c.generateCacheKey("GET", url, "")
    
    // 2. æŸ¥æ‰¾ç¼“å­˜
    if entry, err := c.cache.Get(ctx, cacheKey); err == nil && entry != nil {
        return json.Unmarshal([]byte(entry.Response), result)
    }
    
    // 3. ç¼“å­˜æœªå‘½ä¸­,å‘èµ· HTTP è¯·æ±‚
    if err := c.http.GetJSON(ctx, url, result); err != nil {
        return err
    }
    
    // 4. å†™å…¥ç¼“å­˜
    responseJSON, _ := json.Marshal(result)
    expiresAt := time.Now().Add(c.ttl)
    
    entry := &cache.CacheEntry{
        CacheKey:   cacheKey,
        Model:      "http_cache",
        PromptHash: cacheKey,
        Response:   string(responseJSON),
        ExpiresAt:  &expiresAt,
    }
    
    go c.cache.Set(ctx, entry)
    
    return nil
}

// generateCacheKey ç”ŸæˆHTTPç¼“å­˜é”®
func (c *CachedClient) generateCacheKey(method, url, body string) string {
    data := fmt.Sprintf("%s:%s:%s", method, url, body)
    hash := md5.Sum([]byte(data))
    return hex.EncodeToString(hash[:])
}
```

---

## ç¬¬ä¸‰éƒ¨åˆ†: å®æ–½è·¯çº¿å›¾

### é˜¶æ®µ 1: ç¡¬ç›˜ç¼“å­˜åŸºç¡€å®ç° (1-2 å¤©)

- [ ] åˆ›å»º `backend/internal/cache/disk_cache.go`
- [ ] å®ç° SQLite æ•°æ®åº“åˆå§‹åŒ–
- [ ] å®ç°åŸºç¡€çš„ Get/Set/Delete æ–¹æ³•
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•

### é˜¶æ®µ 2: ç¼“å­˜æ¸…ç†å’Œç»´æŠ¤ (1 å¤©)

- [ ] å®ç°è¿‡æœŸç¼“å­˜è‡ªåŠ¨æ¸…ç†
- [ ] å®ç° LRU ç­–ç•¥
- [ ] å®ç°ç¼“å­˜ç»Ÿè®¡åŠŸèƒ½
- [ ] æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–

### é˜¶æ®µ 3: é›†æˆåˆ° AI æœåŠ¡ (1 å¤©)

- [ ] ä¿®æ”¹ `backend/internal/ai/service.go`
- [ ] é›†æˆä¸‰å±‚ç¼“å­˜é€»è¾‘
- [ ] æ·»åŠ é…ç½®é¡¹
- [ ] é›†æˆæµ‹è¯•

### é˜¶æ®µ 4: HTTP å®¢æˆ·ç«¯å¤ç”¨ (1 å¤©)

- [ ] åˆ›å»º `backend/pkg/httputil/client.go`
- [ ] æŠ½å–å…¬å…± HTTP æ–¹æ³•
- [ ] å®ç°å¸¦ç¼“å­˜çš„ HTTP å®¢æˆ·ç«¯
- [ ] é‡æ„ç°æœ‰å·¥å…·ä½¿ç”¨æ–°å®¢æˆ·ç«¯

### é˜¶æ®µ 5: ç›‘æ§å’Œä¼˜åŒ– (æŒç»­)

- [ ] æ·»åŠ  Prometheus æŒ‡æ ‡
- [ ] ç¼“å­˜å‘½ä¸­ç‡ç›‘æ§
- [ ] æ€§èƒ½åˆ†æå’Œè°ƒä¼˜
- [ ] æ–‡æ¡£å®Œå–„

---

## ç¬¬å››éƒ¨åˆ†: æ€§èƒ½åŸºå‡†æµ‹è¯•

### é¢„æœŸæ€§èƒ½æŒ‡æ ‡

| æ“ä½œ | å»¶è¿Ÿ | QPS | è¯´æ˜ |
|------|------|-----|------|
| SQLite Get | 1-5ms | 10,000+ | ç´¢å¼•æŸ¥è¯¢ |
| SQLite Set | 2-10ms | 5,000+ | å•æ¡æ’å…¥ |
| ç¼“å­˜å‘½ä¸­ç‡ | - | 70-90% | ç”Ÿäº§ç¯å¢ƒ |
| ç£ç›˜ç©ºé—´ | - | 10GB | æ¨èé…ç½® |

### æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **å¯ç”¨ WAL æ¨¡å¼** - æå‡å¹¶å‘å†™å…¥æ€§èƒ½
2. **è°ƒæ•´ç¼“å­˜å¤§å°** - `PRAGMA cache_size=-64000` (64MB)
3. **ä½¿ç”¨å†…å­˜æ˜ å°„** - `PRAGMA mmap_size=268435456` (256MB)
4. **å®šæœŸ VACUUM** - å›æ”¶ç£ç›˜ç©ºé—´
5. **æ‰¹é‡å†™å…¥** - ä½¿ç”¨äº‹åŠ¡æ‰¹é‡æ’å…¥

---

## ç¬¬äº”éƒ¨åˆ†: å¸¸è§é—®é¢˜

### Q1: SQLite æ˜¯å¦æ”¯æŒé«˜å¹¶å‘?

**ç­”**: SQLite æ”¯æŒå¹¶å‘è¯»,ä½†å†™å…¥æ˜¯ä¸²è¡Œçš„ã€‚å¯¹äºè¯»å¤šå†™å°‘çš„ç¼“å­˜åœºæ™¯å®Œå…¨å¤Ÿç”¨ã€‚WAL æ¨¡å¼å¯ä»¥æå‡å¹¶å‘æ€§èƒ½ã€‚

### Q2: ç¼“å­˜æ•°æ®ä¼šä¸¢å¤±å—?

**ç­”**: ç¡¬ç›˜ç¼“å­˜æŒä¹…åŒ–åˆ°ç£ç›˜,æœåŠ¡é‡å¯ä¸ä¼šä¸¢å¤±ã€‚ä½†å»ºè®®é…åˆ Redis ä½¿ç”¨ã€‚

### Q3: å¦‚ä½•å¤„ç†ç¼“å­˜å¤±æ•ˆ?

**ç­”**: æ”¯æŒä¸‰ç§ç­–ç•¥:
1. TTL è¿‡æœŸæ—¶é—´
2. LRU æœ€å°‘ä½¿ç”¨æ·˜æ±°
3. æ‰‹åŠ¨æ¸…é™¤

### Q4: ç¼“å­˜é”®å¦‚ä½•ç”Ÿæˆ?

**ç­”**: ä½¿ç”¨ `MD5(model + prompt)` ç”Ÿæˆå”¯ä¸€é”®ã€‚å¯æ ¹æ®éœ€æ±‚è°ƒæ•´ã€‚

### Q5: å¦‚ä½•ç›‘æ§ç¼“å­˜æ•ˆæœ?

**ç­”**: ä½¿ç”¨ `GetStats()` æ–¹æ³•è·å–ç»Ÿè®¡æ•°æ®,æˆ–é›†æˆ Prometheus ç›‘æ§ã€‚

---

## ç¬¬å…­éƒ¨åˆ†: å‚è€ƒèµ„æ–™

### ç›¸å…³æ–‡æ¡£

- [å¤§æ¨¡å‹ç¼“å­˜æœºåˆ¶åˆ†æ](./å¤§æ¨¡å‹ç¼“å­˜æœºåˆ¶åˆ†æ.md)
- [SQLite å®˜æ–¹æ–‡æ¡£](https://www.sqlite.org/docs.html)
- [Go database/sql åŒ…](https://pkg.go.dev/database/sql)

### ä»£ç ä½ç½®

```
backend/
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ cache/
â”‚   â”‚   â”œâ”€â”€ disk_cache.go          # ç¡¬ç›˜ç¼“å­˜å®ç° (æ–°å¢)
â”‚   â”‚   â””â”€â”€ redis.go                # Redis ç¼“å­˜ (å·²æœ‰)
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â””â”€â”€ builtin/
â”‚   â”‚       â”œâ”€â”€ search_tool.go      # HTTP å®¢æˆ·ç«¯å‚è€ƒ
â”‚   â”‚       â””â”€â”€ web_search.go       # æœç´¢å·¥å…·ç¤ºä¾‹
â”‚   â””â”€â”€ ai/
â”‚       â””â”€â”€ service.go              # AI æœåŠ¡é›†æˆç‚¹
â””â”€â”€ pkg/
    â””â”€â”€ httputil/
        â”œâ”€â”€ client.go               # HTTP å·¥å…·ç±» (æ–°å¢)
        â””â”€â”€ cached_client.go        # å¸¦ç¼“å­˜å®¢æˆ·ç«¯ (æ–°å¢)
```

---

## æ€»ç»“

### ç¡¬ç›˜ç¼“å­˜æ–¹æ¡ˆ

âœ… **æ¨èä½¿ç”¨ SQLite** ä½œä¸ºç¡¬ç›˜ç¼“å­˜å­˜å‚¨æ–¹æ¡ˆ,ä¼˜åŠ¿:
1. é›¶é…ç½®,å•æ–‡ä»¶æ•°æ®åº“
2. æ”¯æŒç´¢å¼•å’Œå…¨æ–‡æœç´¢
3. ACID äº‹åŠ¡ä¿è¯
4. æ€§èƒ½ä¼˜ç§€ (10,000+ QPS)
5. Go åŸç”Ÿæ”¯æŒè‰¯å¥½

### HTTP å®¢æˆ·ç«¯å¤ç”¨

âœ… **ä¸¤ç§å¤ç”¨æ–¹å¼**:
1. **ç›´æ¥å¤åˆ¶** - é€‚åˆå¿«é€Ÿå¼€å‘å•ä¸ªå·¥å…·
2. **æŠ½å–å…¬å…±åº“** - é€‚åˆæ„å»ºå¯ç»´æŠ¤çš„ç³»ç»Ÿ

### å®æ–½ä¼˜å…ˆçº§

1. â­â­â­ å®ç° SQLite ç¡¬ç›˜ç¼“å­˜
2. â­â­â­ é›†æˆåˆ° AI æœåŠ¡
3. â­â­ æŠ½å– HTTP å·¥å…·ç±»
4. â­ å®ç°å¸¦ç¼“å­˜çš„ HTTP å®¢æˆ·ç«¯

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-11-27  
**ä½œè€…**: Claude (AI Assistant)  
**é¡¹ç›®**: AgentFlowCreativeHub
