# 前端命令执行串接方案

## 1. API 层封装
- 在 `frontend/src/features/workspace/api.ts` 中新增 `executeCommand(payload)` 与 `getCommandById(id)` 方法，统一使用现有 `workspaceClient`（或 axios 实例），确保传参字段与后端 `/api/commands` JSON 结构一致，返回类型包含 `request.id`、`status`、`contextSnapshot` 等。
- 为新接口补充 TypeScript 类型定义（例如 `CommandRequestDTO`、`ExecuteCommandResponse`），方便后续组件直接消费。

## 2. CommandConsole 提交与状态管理
- 扩展 `CommandConsole.tsx`：
  - 在提交命令时调用 `executeCommand`，UI 进入 “排队中” 状态，禁用输入按钮并提示 TraceId。
  - 请求成功后将返回的 `request.id` 写入本地 state，并触发状态轮询（见下一节）。
  - 请求失败时，展示后端错误信息，对 `MarkFailed` 场景给出“请稍后重试/补充上下文”文案。

## 3. 状态轮询 Hook
- 在 `frontend/src/features/workspace/hooks.ts`（或新建文件）实现 `useCommandStatus(commandId)`：
  - 使用 `setInterval` 每 2s 调用 `getCommandById`，直到状态进入 `completed/failed`；
  - 处理组件卸载后的清理；
  - 输出 `{status, resultPreview, failureReason, latencyMs, tokenCost}`。
- CommandConsole 以及 Dashboard 的执行记录列表复用该 hook，以统一逻辑。

## 4. UI 呈现与上下文提示
- 在命令结果区域展示：
  - 当前状态（queued/running/completed/failed）及图标；
  - `contextSnapshot` 文本、`notes`，若包含“上下文已部分截断”则高亮警示；
  - `resultPreview` 或失败原因，附带 `latencyMs`、`tokenCost`。
- Dashboard 如已有命令列表，则在卡片中追加状态徽标；若不存在，则至少在 CommandConsole 中完整展示。

## 5. 校验与测试
- 更新/新增组件测试：
  - `CommandConsole`：mock API，覆盖成功排队、失败提示、状态切换；
  - `useCommandStatus`：使用 fake timers 或 jest.spyOn(interval) 验证轮询/清理逻辑。
- 运行 `cd frontend && npm test -- CommandConsole` 以及 `npm run lint` 确保无回归。

如确认方案，我将按以上步骤实施。