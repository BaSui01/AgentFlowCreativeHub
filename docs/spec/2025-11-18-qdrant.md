## 目标
将当前依赖 pgvector 的 RAG 向量能力迁移至唯一的外部 Qdrant 集群，并提前识别潜在问题、迭代步骤和风险防控。

## 分阶段方案
1. **抽象层与配置基线**
   - 定义 `VectorStore` 接口，列出必须实现的方法（Add/Search/Delete/Stats），并为未来多后端留扩展点。
   - 配置文件新增 `rag.vector_store.type`（当前强制为 `qdrant`），同时提供连接参数（endpoint、API key、collection 前缀、向量维度、超时、重试策略）。

2. **QdrantStore 实现细节**
   - 基于 `github.com/qdrant/go-client` 实现：
     - `AddVectors` → `UpsertPoints`，支持批量写入、payload（tenant_id、knowledge_base_id、document_id、chunk_index、metadata）。
     - `Search` → `SearchPoints`，余弦相似度 + payload filter（tenant + kb）。
     - 删除支持 `DeletePoints` (by IDs) 与 `Delete` (by filters) 两种路径，以便实现 `DeleteByDocument/KnowledgeBase`。
     - 统计通过 `Count` + payload filter 获取。
   - 提供集合管理：在初始化阶段检测/创建 collection，配置向量维度、HNSW 参数、副本数和量化设置。

3. **RAGService 与管线改造**
   - `RAGService` 仅依赖 `VectorStore` 接口，去除直接 SQL 操作。
   - `ProcessDocument`、`Search`、`DeleteDocument` 等调用更新为使用 Qdrant store。
   - 补充错误处理与重试：对 Qdrant 网络失败、超时、限流进行重试/告警。

4. **数据迁移策略**
   - 编写迁移脚本：扫描 `knowledge_chunks`，按知识库批量推送至 Qdrant，对比计数校验。
   - 迁移过程中可设置双写（pgvector + Qdrant）或一次性停机导出；迁移完成后标注“Qdrant-only”版本，并关闭 pgvector 插件依赖。
   - 为 Rollback 预留方案：保留旧数据备份和开关，必要时可切回 pgvector（借助接口层）。

5. **监控与可观测性**
   - 增加 Qdrant 指标：写入/搜索延迟、失败率、重试次数、集合容量等，接入 Prometheus。
   - 周期性健康检查：集合分片、副本状态、磁盘使用。若探测到异常，触发报警。

6. **性能与成本评估**
   - 预估向量规模（文档数量 * 平均块数），对照 Qdrant 的内存/磁盘需求。
   - 压测写入和查询：确定 batch 大小、HNSW M/efConstruction、quantization 方案，以满足 SLA。
   - 结合部署方式（自建 vs 托管）计算成本，并制定容量扩展计划。

7. **安全与访问控制**
   - 统一通过 API Key 或 mTLS 访问 Qdrant；在配置中提供安全参数。
   - 明确多租户隔离策略（payload filter + ACL），避免跨租户数据泄露。

8. **风险清单与应对**
   - **网络依赖**：外部服务不可用 → 重试/熔断 + 备用集群。
   - **一致性**：写入失败导致数据缺失 → 事务性补偿（失败记录重放队列）。
   - **数据迁移**：旧向量未全部迁移 → 迁移脚本需校验计数与样本抽检。
   - **成本飙升**：集合膨胀 → 定期归档老文档或启用压缩。

确认以上迭代方案后，可按“接口抽象 → QdrantStore 实现 → 配置切换 → 数据迁移 → 监控/性能调优”的顺序逐步落地。