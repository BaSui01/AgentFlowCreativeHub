# 硬盘缓存与HTTP客户端实施任务清单

> **项目**: AgentFlowCreativeHub  
> **文档版本**: v1.0  
> **创建日期**: 2025-11-27  
> **预计工期**: 5-6 天  
> **参考文档**: [硬盘缓存与互联网检索复用方案.md](./硬盘缓存与互联网检索复用方案.md)

---

## 📋 任务概览

| 阶段 | 任务数 | 预计时间 | 优先级 | 状态 |
|------|--------|----------|--------|------|
| 阶段1: 硬盘缓存基础 | 8 | 1-2天 | P0 | ⏳ 待开始 |
| 阶段2: 缓存清理维护 | 6 | 1天 | P0 | ⏳ 待开始 |
| 阶段3: 集成AI服务 | 7 | 1天 | P0 | ⏳ 待开始 |
| 阶段4: HTTP客户端复用 | 8 | 1天 | P1 | ⏳ 待开始 |
| 阶段5: 监控和优化 | 6 | 持续 | P1 | ⏳ 待开始 |
| **总计** | **35** | **5-6天** | - | **0/35** |

---

## 🎯 阶段 1: 硬盘缓存基础实现

**目标**: 实现 SQLite 硬盘缓存的核心功能  
**预计时间**: 1-2 天  
**优先级**: P0 (必须完成)

### 任务清单

- [ ] **1.1 创建缓存包结构**
  - 文件: `backend/internal/cache/disk_cache.go`
  - 内容: 包声明、导入依赖
  - 预计: 10 分钟
  - 参考: 文档第一部分 1.3 节

- [ ] **1.2 定义缓存数据结构**
  ```go
  - [ ] DiskCache 结构体
  - [ ] CacheEntry 结构体
  - [ ] 配置参数结构体
  ```
  - 预计: 30 分钟
  - 参考: 文档代码片段 "缓存结构体定义"

- [ ] **1.3 实现数据库初始化**
  ```go
  - [ ] initSchema() 函数 - 创建表结构
  - [ ] 创建 llm_cache 主表
  - [ ] 创建 cache_stats 统计表
  - [ ] 创建必要的索引
  - [ ] 设置 SQLite 性能优化参数
  ```
  - 预计: 1 小时
  - 参考: 文档 Schema 设计部分

- [ ] **1.4 实现 NewDiskCache 构造函数**
  ```go
  - [ ] 打开 SQLite 数据库连接
  - [ ] 调用 initSchema 初始化表结构
  - [ ] 设置 PRAGMA 性能参数
  - [ ] 启动后台清理协程
  - [ ] 错误处理和验证
  ```
  - 预计: 1 小时
  - 参考: 文档 "NewDiskCache 创建硬盘缓存实例"

- [ ] **1.5 实现 GenerateCacheKey 函数**
  ```go
  - [ ] MD5 哈希生成
  - [ ] 支持 model + prompt 组合
  - [ ] 十六进制编码
  ```
  - 预计: 20 分钟
  - 参考: 文档 "GenerateCacheKey 生成缓存键"

- [ ] **1.6 实现 Get 方法**
  ```go
  - [ ] SQL 查询语句
  - [ ] 过期时间验证
  - [ ] 结果扫描和映射
  - [ ] 未命中返回 nil
  - [ ] 错误处理
  ```
  - 预计: 1 小时
  - 参考: 文档 "Get 读取缓存"

- [ ] **1.7 实现 Set 方法**
  ```go
  - [ ] INSERT OR REPLACE 语句
  - [ ] TTL 计算
  - [ ] 冲突处理 (UPSERT)
  - [ ] 后台触发大小检查
  ```
  - 预计: 1 小时
  - 参考: 文档 "Set 写入缓存"

- [ ] **1.8 实现 Delete 和 Clear 方法**
  ```go
  - [ ] Delete - 删除单条记录
  - [ ] Clear - 清空所有缓存
  - [ ] Close - 关闭数据库连接
  ```
  - 预计: 30 分钟

### 验收标准

- ✅ 所有代码编译通过无错误
- ✅ 可以创建 DiskCache 实例
- ✅ 可以写入和读取缓存数据
- ✅ 数据库文件正确创建在指定路径
- ✅ 索引和 PRAGMA 设置正确

---

## 🧹 阶段 2: 缓存清理和维护

**目标**: 实现缓存过期清理、LRU淘汰、统计功能  
**预计时间**: 1 天  
**优先级**: P0 (必须完成)

### 任务清单

- [ ] **2.1 实现 incrementHitCount 方法**
  ```go
  - [ ] 更新 hit_count 字段
  - [ ] 更新 last_accessed_at 时间戳
  - [ ] 异步执行避免阻塞
  ```
  - 预计: 30 分钟
  - 参考: 文档 "incrementHitCount 增加命中计数"

- [ ] **2.2 实现 cleanupLoop 定期清理**
  ```go
  - [ ] 创建定时器 (1小时间隔)
  - [ ] Context 取消支持
  - [ ] 调用 cleanup 方法
  - [ ] 错误处理和日志
  ```
  - 预计: 1 小时
  - 参考: 文档 "cleanupLoop 定期清理过期缓存"

- [ ] **2.3 实现 cleanup 清理逻辑**
  ```go
  - [ ] 删除过期条目 (expires_at < now)
  - [ ] 执行 VACUUM 压缩
  - [ ] 日志记录清理结果
  ```
  - 预计: 1 小时
  - 参考: 文档 "cleanup 执行清理操作"

- [ ] **2.4 实现 checkAndCleanup LRU 淘汰**
  ```go
  - [ ] 计算当前缓存总大小
  - [ ] 与 maxSize 比较
  - [ ] 删除最旧的 10% 数据 (按 last_accessed_at)
  - [ ] 日志记录
  ```
  - 预计: 1.5 小时
  - 参考: 文档 "checkAndCleanup 检查缓存大小并清理"

- [ ] **2.5 实现 GetStats 统计方法**
  ```go
  - [ ] 总条目数
  - [ ] 总命中次数
  - [ ] 总大小 (KB/MB)
  - [ ] 平均命中次数
  - [ ] 最旧/最新条目时间
  ```
  - 预计: 1 小时
  - 参考: 文档 "GetStats 获取缓存统计"

- [ ] **2.6 编写单元测试 (cache_test.go)**
  ```go
  - [ ] TestNewDiskCache - 创建实例
  - [ ] TestSetAndGet - 写入读取
  - [ ] TestCacheExpiration - 过期测试
  - [ ] TestCacheLRU - LRU 淘汰测试
  - [ ] TestGetStats - 统计功能测试
  - [ ] 清理测试数据库文件
  ```
  - 预计: 2 小时

### 验收标准

- ✅ 过期缓存自动清理
- ✅ 缓存大小超限时触发 LRU 淘汰
- ✅ GetStats 返回正确统计数据
- ✅ 单元测试覆盖率 > 80%
- ✅ 所有测试通过

---

## 🔗 阶段 3: 集成到 AI 服务

**目标**: 将硬盘缓存集成到现有 AI 服务,实现三层缓存架构  
**预计时间**: 1 天  
**优先级**: P0 (必须完成)

### 任务清单

- [ ] **3.1 更新配置文件**
  - 文件: `backend/configs/config.yaml`
  ```yaml
  - [ ] 添加 cache.disk 配置节
  - [ ] db_path 配置
  - [ ] max_size_gb 配置
  - [ ] ttl 配置
  - [ ] enabled 开关
  ```
  - 预计: 15 分钟
  - 参考: 文档 1.4 节 "配置文件修改"

- [ ] **3.2 更新配置结构体**
  - 文件: `backend/internal/config/config.go`
  ```go
  - [ ] 定义 DiskCacheConfig 结构体
  - [ ] 添加到 CacheConfig
  - [ ] 添加默认值
  - [ ] 添加验证逻辑
  ```
  - 预计: 30 分钟

- [ ] **3.3 修改 AI Service 结构体**
  - 文件: `backend/internal/ai/service.go`
  ```go
  - [ ] 添加 diskCache *cache.DiskCache 字段
  - [ ] 导入 cache 包
  ```
  - 预计: 10 分钟

- [ ] **3.4 修改 NewAIService 构造函数**
  ```go
  - [ ] 检查 disk cache 配置是否启用
  - [ ] 创建 DiskCache 实例
  - [ ] 错误处理
  - [ ] 添加到 service 结构体
  ```
  - 预计: 30 分钟
  - 参考: 文档 1.4 节 "使用示例"

- [ ] **3.5 实现三层缓存查询逻辑**
  - 修改 Chat/Completion 方法
  ```go
  - [ ] L1: 内存缓存查找
  - [ ] L2: Redis 缓存查找
  - [ ] L3: 硬盘缓存查找 (新增)
  - [ ] 缓存未命中调用 LLM API
  - [ ] 记录缓存命中/未命中日志
  ```
  - 预计: 2 小时
  - 参考: 文档 "Chat 聊天方法 (集成三层缓存)"

- [ ] **3.6 实现缓存回填逻辑**
  ```go
  - [ ] L3 命中后回填 L2 (Redis)
  - [ ] L3 命中后回填 L1 (内存)
  - [ ] 异步执行避免阻塞
  - [ ] 错误处理不影响主流程
  ```
  - 预计: 1 小时

- [ ] **3.7 实现缓存写入逻辑**
  ```go
  - [ ] LLM 响应后写入 L3 (disk)
  - [ ] 同时写入 L2 (Redis)
  - [ ] 同时写入 L1 (内存)
  - [ ] 异步执行
  - [ ] 计算成本并记录
  ```
  - 预计: 1 小时

### 验收标准

- ✅ 配置正确加载
- ✅ AI Service 可以创建 DiskCache
- ✅ 三层缓存查询顺序正确: L1 → L2 → L3 → API
- ✅ 缓存回填机制正常工作
- ✅ LLM 响应正确写入所有缓存层
- ✅ 日志清晰标记缓存命中层级

---

## 🌐 阶段 4: HTTP 客户端复用

**目标**: 创建通用 HTTP 工具类,减少重复代码  
**预计时间**: 1 天  
**优先级**: P1 (推荐完成)

### 任务清单

- [ ] **4.1 创建 httputil 包**
  - 目录: `backend/pkg/httputil/`
  - 文件: `client.go`
  - 预计: 5 分钟

- [ ] **4.2 实现 Client 结构体**
  ```go
  - [ ] 定义 Client 结构体
  - [ ] client *http.Client 字段
  - [ ] userAgent string 字段
  - [ ] timeout time.Duration 字段
  ```
  - 预计: 15 分钟
  - 参考: 文档 2.2 节 "方案2"

- [ ] **4.3 实现 NewClient 构造函数**
  ```go
  - [ ] 创建 http.Client
  - [ ] 设置超时时间
  - [ ] 设置默认 User-Agent
  - [ ] 可配置参数
  ```
  - 预计: 20 分钟

- [ ] **4.4 实现 GetJSON 方法**
  ```go
  - [ ] 创建 GET 请求
  - [ ] 设置 Context
  - [ ] 设置请求头 (User-Agent, Accept)
  - [ ] 发送请求
  - [ ] 读取响应
  - [ ] JSON 解析
  - [ ] 错误处理
  ```
  - 预计: 1 小时
  - 参考: 文档 "GetJSON 发送 GET 请求并解析 JSON"

- [ ] **4.5 实现 PostJSON 方法**
  ```go
  - [ ] 序列化请求体
  - [ ] 创建 POST 请求
  - [ ] 设置 Content-Type: application/json
  - [ ] 发送请求
  - [ ] 解析响应
  - [ ] 错误处理
  ```
  - 预计: 1 小时
  - 参考: 文档 "PostJSON 发送 POST 请求"

- [ ] **4.6 创建带缓存的客户端 (cached_client.go)**
  ```go
  - [ ] CachedClient 结构体
  - [ ] 集成 DiskCache
  - [ ] NewCachedClient 构造函数
  ```
  - 预计: 30 分钟
  - 参考: 文档 2.3 节

- [ ] **4.7 实现 GetJSONWithCache 方法**
  ```go
  - [ ] 生成缓存键 (MD5)
  - [ ] 查找缓存
  - [ ] 缓存命中直接返回
  - [ ] 缓存未命中发起 HTTP 请求
  - [ ] 写入缓存
  - [ ] 异步缓存写入
  ```
  - 预计: 1.5 小时
  - 参考: 文档 "GetJSONWithCache 带缓存的 GET 请求"

- [ ] **4.8 重构现有工具使用新客户端**
  ```go
  - [ ] 修改 SearchTool 使用 httputil.Client
  - [ ] 修改 WebSearchTool 使用 httputil.Client
  - [ ] 删除重复的 HTTP 代码
  - [ ] 保持向后兼容
  ```
  - 预计: 1 小时

### 验收标准

- ✅ httputil 包编译通过
- ✅ GetJSON/PostJSON 方法正常工作
- ✅ CachedClient 可以缓存 HTTP 响应
- ✅ 现有工具成功迁移到新客户端
- ✅ 功能测试通过,无回归问题

---

## 📊 阶段 5: 监控和优化

**目标**: 添加监控指标,性能测试和优化  
**预计时间**: 持续进行  
**优先级**: P1 (推荐完成)

### 任务清单

- [ ] **5.1 添加 Prometheus 指标**
  - 文件: `backend/internal/cache/metrics.go`
  ```go
  - [ ] cache_hits_total (按层级统计)
  - [ ] cache_misses_total
  - [ ] cache_hit_rate (计算指标)
  - [ ] cache_size_bytes
  - [ ] cache_operation_duration_seconds
  - [ ] cache_cost_savings_usd (成本节省)
  ```
  - 预计: 2 小时

- [ ] **5.2 添加日志记录**
  ```go
  - [ ] 缓存命中/未命中日志
  - [ ] 缓存大小超限日志
  - [ ] LRU 淘汰日志
  - [ ] 清理操作日志
  - [ ] 使用 zap logger
  ```
  - 预计: 1 小时

- [ ] **5.3 性能测试**
  - 文件: `backend/internal/cache/disk_cache_bench_test.go`
  ```go
  - [ ] BenchmarkDiskCacheGet - 读取性能
  - [ ] BenchmarkDiskCacheSet - 写入性能
  - [ ] BenchmarkConcurrentAccess - 并发性能
  - [ ] 目标: Get > 10,000 QPS
  ```
  - 预计: 2 小时

- [ ] **5.4 创建监控大盘配置**
  - 文件: `deploy/grafana/cache-dashboard.json`
  ```json
  - [ ] 缓存命中率趋势图
  - [ ] 三层缓存命中分布饼图
  - [ ] 缓存大小变化曲线
  - [ ] 成本节省统计
  - [ ] QPS 和延迟监控
  ```
  - 预计: 2 小时

- [ ] **5.5 数据库索引优化**
  ```sql
  - [ ] 分析慢查询
  - [ ] 添加复合索引 (如需要)
  - [ ] ANALYZE 命令更新统计信息
  - [ ] VACUUM 定期维护
  ```
  - 预计: 1 小时

- [ ] **5.6 编写运维文档**
  - 文件: `docs/运维指南-缓存系统.md`
  ```markdown
  - [ ] 缓存配置说明
  - [ ] 监控指标说明
  - [ ] 常见问题排查
  - [ ] 性能调优建议
  - [ ] 备份和恢复
  ```
  - 预计: 2 小时

### 验收标准

- ✅ Prometheus 指标正常暴露
- ✅ Grafana 大盘可视化正常
- ✅ 性能测试达到预期 (10,000+ QPS)
- ✅ 日志完整清晰
- ✅ 运维文档完善

---

## 🔍 质量检查清单

### 代码质量

- [ ] **代码规范**
  - [ ] 遵循 Go 代码规范
  - [ ] 通过 golint 检查
  - [ ] 通过 go vet 检查
  - [ ] 格式化 (gofmt)

- [ ] **错误处理**
  - [ ] 所有错误都有处理
  - [ ] 错误信息清晰
  - [ ] 使用 fmt.Errorf 包装错误
  - [ ] 日志记录关键错误

- [ ] **并发安全**
  - [ ] 数据库连接池安全
  - [ ] 避免 race condition
  - [ ] 使用 go test -race 测试

- [ ] **性能优化**
  - [ ] 使用 Context 传递取消信号
  - [ ] 异步操作不阻塞主流程
  - [ ] 批量操作减少数据库调用
  - [ ] 索引优化查询性能

### 测试覆盖

- [ ] **单元测试**
  - [ ] 覆盖率 > 80%
  - [ ] 所有公共方法有测试
  - [ ] 边界条件测试
  - [ ] 错误场景测试

- [ ] **集成测试**
  - [ ] AI Service 集成测试
  - [ ] 三层缓存联调测试
  - [ ] HTTP 客户端集成测试

- [ ] **性能测试**
  - [ ] Benchmark 测试
  - [ ] 并发压力测试
  - [ ] 内存泄漏检测

### 文档完善

- [ ] **代码注释**
  - [ ] 所有导出函数有注释
  - [ ] 复杂逻辑有说明
  - [ ] 包级别文档

- [ ] **使用文档**
  - [ ] README 更新
  - [ ] 配置说明文档
  - [ ] API 文档更新
  - [ ] 运维指南

---

## 📈 进度跟踪

### 每日更新

| 日期 | 完成任务 | 遇到问题 | 明日计划 |
|------|----------|----------|----------|
| 2025-11-27 | - | - | 开始阶段1 |
| - | - | - | - |
| - | - | - | - |

### 阶段完成度

```
阶段1: [          ] 0/8   (0%)
阶段2: [          ] 0/6   (0%)
阶段3: [          ] 0/7   (0%)
阶段4: [          ] 0/8   (0%)
阶段5: [          ] 0/6   (0%)
─────────────────────────────
总计:  [          ] 0/35  (0%)
```

---

## 🎯 成功标准

### 功能完整性

- ✅ 可以创建和使用硬盘缓存
- ✅ 三层缓存架构正常工作
- ✅ 缓存自动清理和淘汰
- ✅ HTTP 客户端可复用
- ✅ 带缓存的 HTTP 客户端工作

### 性能指标

- ✅ SQLite 缓存读取 QPS > 10,000
- ✅ 缓存命中率 > 60%
- ✅ L3 缓存延迟 < 20ms
- ✅ 无明显性能回归

### 质量指标

- ✅ 单元测试覆盖率 > 80%
- ✅ 所有测试通过
- ✅ 无编译警告
- ✅ 代码审查通过

### 监控指标

- ✅ Prometheus 指标正常采集
- ✅ Grafana 大盘可视化
- ✅ 日志完整清晰
- ✅ 告警规则配置

---

## 🚧 风险和缓解

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| SQLite 并发性能不足 | 高 | 中 | 使用 WAL 模式,读写分离 |
| 硬盘空间占用过大 | 中 | 中 | LRU 淘汰,定期清理,压缩存储 |
| 缓存一致性问题 | 高 | 低 | TTL 机制,手动失效接口 |
| 集成影响现有功能 | 高 | 低 | 充分测试,灰度发布 |
| 性能回归 | 中 | 低 | Benchmark 测试,性能监控 |

---

## 📚 参考资料

### 内部文档

- [硬盘缓存与互联网检索复用方案.md](./硬盘缓存与互联网检索复用方案.md)
- [大模型缓存机制分析.md](./大模型缓存机制分析.md)
- [功能清单.md](./功能清单.md)

### 外部资源

- [SQLite 官方文档](https://www.sqlite.org/docs.html)
- [Go database/sql 包](https://pkg.go.dev/database/sql)
- [go-sqlite3 驱动](https://github.com/mattn/go-sqlite3)
- [SQLite 性能优化](https://www.sqlite.org/performance.html)

### 相关代码

- `backend/internal/tools/builtin/search_tool.go` - HTTP 客户端参考实现
- `backend/internal/tenant/config_cache.go` - 缓存模式参考
- `backend/internal/ai/service.go` - AI 服务集成点

---

## 📝 备注

### 开发建议

1. **遵循 TDD** - 先写测试,再写实现
2. **小步迭代** - 每完成一个任务立即测试
3. **及时提交** - 每个阶段完成后提交代码
4. **代码审查** - 关键代码请同事审查
5. **文档同步** - 代码和文档同步更新

### 可选优化

以下功能可在基础实现完成后逐步添加:

- [ ] 缓存压缩 (gzip) 减少存储空间
- [ ] 批量写入优化性能
- [ ] 分布式缓存同步 (可选)
- [ ] 缓存预热机制
- [ ] 智能缓存策略 (基于访问模式)

---

**任务负责人**: [开发者姓名]  
**审核人**: [审核者姓名]  
**开始日期**: 2025-11-27  
**目标完成日期**: 2025-12-03

---

> 💡 **提示**: 使用此清单时,每完成一项任务请在 `[ ]` 中打勾 `[x]`,并更新进度跟踪表格。

> ⚠️ **注意**: 如遇到技术难题或进度延误,请及时在进度跟踪中记录,并寻求帮助。
